package br.ufu.facom.lascam.coverageexploiter.analytics;

import java.util.Collections;
import java.util.Date;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

import org.apache.commons.lang3.StringUtils;

import br.ufu.facom.lascam.coverageexploiter.analytics.model.ElementMetric;
import br.ufu.facom.lascam.coverageexploiter.analytics.model.ElementsMetric;
import br.ufu.facom.lascam.coverageexploiter.evaluation.SnippetsForEvaluation;
import br.ufu.facom.lascam.coverageexploiter.extractor.ApiExtractor;
import br.ufu.facom.lascam.coverageexploiter.parser.impl.RegexJavaAnalyser;
import br.ufu.facom.lascam.coverageexploiter.parser.model.CitedElements;
import br.ufu.facom.lascam.coverageexploiter.posts.model.classifier.Pair;

/**
 * Created by Klerisson on 23/10/2014.
 */
public class CoverageMetrics {

	private Map<String, Set<String>> targetApiPackagesToClasses;
	private Map<String, Set<String>> targetApiClassesToMethods;
	private HashSet<String> apiElements;
	private List<Pair> postsPair;
	private ElementsMetric elementsMetric;

	private ExecutorService pool;
	private CountDownLatch latch;

	private int answersWithSnippet;
	private int answersWithoutSnippet;
	
	private int packagesOfTheAPI, classesOfTheAPI, methodsOfTheAPI;

	public CoverageMetrics(List<Pair> postsPair, ApiExtractor extractor) {
		this.postsPair = Collections.unmodifiableList(postsPair);
		this.packagesOfTheAPI = 0;
		this.classesOfTheAPI = 0;
		this.methodsOfTheAPI = 0;
		this.targetApiPackagesToClasses = extractor.getPackagesToClassesMap();
		this.targetApiClassesToMethods = extractor.getClassesToMethodsMap();
		this.apiElements = extractAllElements(this.targetApiPackagesToClasses, this.targetApiClassesToMethods);
		this.elementsMetric = new ElementsMetric();
		this.pool = Executors.newFixedThreadPool(11);
		this.latch = new CountDownLatch(postsPair.size());
		this.answersWithSnippet = 0;
		this.answersWithoutSnippet = 0;
	}

	public void evaluate() {
		
		for (final Pair p : postsPair) {

			Runnable r = new Runnable() {
				@Override
				public void run() {
					doTheWork(p);
				}
			};
			pool.execute(r);
		}

		try {
			latch.await();
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		pool.shutdown();
		try {
			pool.awaitTermination(10, TimeUnit.MINUTES);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}

		System.out.println("Answers with snippet: " + answersWithSnippet);
		System.out.println("Answers without snippet: " + answersWithoutSnippet);

		CoverageResults.getInstance().writeDataSheet(elementsMetric, packagesOfTheAPI, classesOfTheAPI, methodsOfTheAPI);
		SnippetsForEvaluation.getInstance().writeDocument();
		HeatMap.create(this.elementsMetric, targetApiPackagesToClasses, targetApiClassesToMethods);
	}

	private void doTheWork(Pair p) {
		try {
			// BakerIntegrator baker = new BakerIntegrator();
			// PartialProgramAnalyser myPPA = new PartialProgramAnalyser();
			RegexJavaAnalyser regexAnalyser = new RegexJavaAnalyser();

			String statement = p.getAnswer().getCode();
			Date statementDate = p.getAnswer().getCreationDate();
			if (StringUtils.isNotBlank(statement)) {
				answersWithSnippet++;
				try {
					// baker.parseSnippet(statement);
					// myPPA.parseSnippet(statement);
					CitedElements citedElements = regexAnalyser.parseSnippet(statement);
					// HashSet<String> elements = baker.getAllElements();
					// HashSet<String> elements = myPPA.getAllElements();
					
					Set<String> matches;
					
					// Packages
					for (String pack : citedElements.getPackages()) {
						matches = new HashSet<String>();
						String apiElement = this.fetchElementOnTheApi(pack, "package", matches);
						if (apiElement != null) {
							ElementMetric em = new ElementMetric(apiElement, "package", matches, statementDate);
							this.elementsMetric.add(em);
						}
					}
					
					// Classes
					for (String clazz : citedElements.getClasses()) {
						matches = new HashSet<String>();
						String apiElement = this.fetchElementOnTheApi(clazz, "class", matches);
						if (apiElement != null) {
							ElementMetric em = new ElementMetric(apiElement, "class", matches, statementDate);
							this.elementsMetric.add(em);
						}
					}
					
					// Methods
					for (String method : citedElements.getMethods()) {
						matches = new HashSet<String>();
						String apiElement = this.fetchElementOnTheApi(method, "method", matches);
						if (apiElement != null) {
							ElementMetric em = new ElementMetric(apiElement, "method", matches, statementDate);
							this.elementsMetric.add(em);
						}
					}
					
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				answersWithoutSnippet++;
			}
		} finally {
			latch.countDown();
			System.out.println(latch.getCount());
		}
	}

	private String fetchElementOnTheApi(String element, String type, Set<String> matches) {
		if (type.equals("method") || type.equals("class")) {
			if (apiElements.contains(element)) { // fully bound -> method case: <package>.<class>.<method> and class case: <package>.<class>
				matches.add(element);
				return element;
			} else {
				//int matches = 0;
				Iterator<String> it = this.apiElements.iterator();
				String apiElement;
				while (it.hasNext()) {
					apiElement = it.next();
					if (apiElement.endsWith(".".concat(element))) {
						matches.add(apiElement);
					}
				}
				if (!matches.isEmpty()) {
					if (matches.size() == 1) {
						return matches.iterator().next();
					} else {
						return element;
					}
				}
			}
		} else { // package
			if (apiElements.contains(element)) {
				matches.add(element);
				return element;
			}
		}
		
		return null;
	}

	private HashSet<String> extractAllElements(Map<String, Set<String>> targetApiPackagesToClasses, Map<String, Set<String>> targetApiClassesToMethods) {

		HashSet<String> resultSet = new HashSet<>();
		
		for (Map.Entry<String, Set<String>> entry : targetApiPackagesToClasses.entrySet()) {
			// Package element
			resultSet.add(entry.getKey());
			packagesOfTheAPI++;
		}
		for (Map.Entry<String, Set<String>> entry : targetApiClassesToMethods.entrySet()) {
			// Class element
			resultSet.add(entry.getKey());
			classesOfTheAPI++;
			for (String method : entry.getValue()) {
				// Method element
				resultSet.add(method);
				methodsOfTheAPI++;
			}
		}
		return resultSet;
	}
}