package br.ufu.facom.lascam.coverageexploiter.analytics;

import br.ufu.facom.lascam.coverageexploiter.analytics.model.ElementMetric;
import br.ufu.facom.lascam.coverageexploiter.analytics.model.ElementsMetric;
import br.ufu.facom.lascam.coverageexploiter.extractor.ApiExtractor;
import br.ufu.facom.lascam.coverageexploiter.parser.impl.RegexAnalyser;
import br.ufu.facom.lascam.coverageexploiter.posts.model.classifier.Pair;
import org.apache.commons.collections4.CollectionUtils;
import org.apache.commons.lang3.StringUtils;

import java.util.*;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

/**
 * Created by Klerisson on 23/10/2014.
 */
public class CoverageMetrics {

    private Map<String, Set<String>> targetApiClassesToMethods;
    private HashSet<String> apiElements;
    private List<Pair> postsPair;
    private ElementsMetric elementsMetric;

    private ExecutorService pool;
    //private AtomicInteger statusCounter;
    private CountDownLatch latch;

    public CoverageMetrics(List<Pair> postsPair, ApiExtractor extractor) {
        this.postsPair = Collections.unmodifiableList(postsPair);
        this.targetApiClassesToMethods = extractor.getClassesToMethodsMap();
        this.apiElements = extractAllElements(this.targetApiClassesToMethods);
        this.elementsMetric = new ElementsMetric();
        this.pool = Executors.newFixedThreadPool(1);
        latch = new CountDownLatch(postsPair.size());
    }

    public void evaluate() {

        for (final Pair p : postsPair) {

            Runnable r = new Runnable() {
                @Override
                public void run() {
                    doTheWork(p);
                }
            };
            pool.execute(r);
        }

        try {
            latch.await();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        pool.shutdown();
        try {
            pool.awaitTermination(10, TimeUnit.MINUTES);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        Output.getInstance().writeDataSheet(elementsMetric);
    }

    private void doTheWork(Pair p) {
        try {
            //BakerIntegrator baker = new BakerIntegrator();
            //PartialProgramAnalyser myPPA = new PartialProgramAnalyser();
            RegexAnalyser regexAnalyser = new RegexAnalyser();

            String statement = p.getAnswer().getCode();
            Date statementDate = p.getAnswer().getCreationDate();
            if (StringUtils.isNotBlank(statement)) {

                try {
                    //baker.parseSnippet(statement);
                    // myPPA.parseSnippet(statement);
                    regexAnalyser.parseSnippet(statement);
                    //HashSet<String> elements = baker.getAllElements();
                    //HashSet<String> elements = myPPA.getAllElements();
                    HashSet<String> elements = regexAnalyser.getAllElements();

                    if (CollectionUtils.isNotEmpty(elements)) {
                        for (String element : elements) {
                            if (isElementOnTheApi(element)) {
                                ElementMetric em = new ElementMetric(element, statementDate);
                                this.elementsMetric.add(em);
                            }
                        }
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        } finally {
            latch.countDown();
            System.out.println(latch.getCount());
        }
    }

    private boolean isElementOnTheApi(String element) {
        return this.apiElements.contains(element);
    }

    private HashSet<String> extractAllElements(Map<String, Set<String>> targetApiClassesToMethods) {

        HashSet<String> resultSet = new HashSet<>();
        for (Map.Entry<String, Set<String>> entry : targetApiClassesToMethods.entrySet()) {
            //Class element
            resultSet.add(entry.getKey());
            for (String method : entry.getValue()) {
                //Method full qualified name
                //resultSet.add(entry.getKey() + "." + method);
                resultSet.add(method);
            }
        }
        return resultSet;
    }
}