package br.ufu.facom.lascam.coverageexploiter.evaluation;

import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.regex.Pattern;

import org.apache.poi.xwpf.usermodel.XWPFParagraph;

import br.ufu.facom.lascam.coverageexploiter.parser.impl.RegexJavaAnalyser;

/**
 * TestCase.java represents test case, in which contains the input and the
 * expected output data. By execution of the test case, the parser and the
 * binder are exercised, generating output elements. These elements, together
 * with the expected elements, are checked by TestChecker.java.
 * <p>
 * Created by Fer Madeiral on 20/11/2014.
 */
public class TestCase {

	/**
	 * A snippet to be sent to parser/binder as input.
	 */
	private String input;
	private List<XWPFParagraph> codeParagraphs; // recorded only for generate
												// the detailed evaluation
												// report with the snippets
												// formatted in
												// "SnippetsForEvaluation.docx"

	/**
	 * Elements that are relevant to be parsed.
	 */
	private Set<String> parserRelevantElementsSet;
	/**
	 * Elements that were returned (relevant and non-relevant) by parser.
	 */
	private Set<String> parserReturnedElementsSet;
	/**
	 * Elements that are relevant to be bound.
	 */
	private Set<String> binderRelevantElementsSet;
	/**
	 * Elements that were submitted by parser to binder.
	 */
	private Set<String> binderSubmittedElementsSet;
	/**
	 * Elements that were submitted by parser to binder that are relevant and
	 * bindable.
	 */
	private Set<String> bindableElementsSet;
	/**
	 * Elements that were bound (relevant and non-relevant) by binder.
	 */
	private Set<String> binderReturnedElementsSet;

	/**
	 * Resulting elements containing true positives, false negatives and false
	 * positives.
	 */
	private ResultingElements parserResultingElements; // related with
														// parserRelevantElementsSet
														// and
														// parserReturnedElementsSet
	private ResultingElements parserToBinderResultingElements; // related with
																// binderRelevantElementsSet
																// and
																// binderSubmittedElementsSet
	private ResultingElements binderResultingElements; // related with
														// bindableElementsSet
														// and
														// binderReturnedElementsSet

	/**
	 * Elements captured by IdentifiedElements.aj that were identified in the
	 * snippet.
	 */
	private Set<String> normalElements;
	private Set<String> boundElements;
	private Set<String> notBoundElements;

	TestCase(String input, String output) {
		this.input = input;
		parserRelevantElementsSet = new HashSet<>();
		binderRelevantElementsSet = new HashSet<>();
		if (!output.isEmpty()) {
			String[] elements = output.split(",");
			for (String element : elements) {
				element = element.trim();
				parserRelevantElementsSet.add(element);
				if (element.contains("<")) {
					binderRelevantElementsSet.add(element);
				}
			}
		}

		parserReturnedElementsSet = new HashSet<>();
		binderSubmittedElementsSet = new HashSet<>();
		bindableElementsSet = new HashSet<>();
		binderReturnedElementsSet = new HashSet<>();

		parserResultingElements = new ResultingElements();
		parserToBinderResultingElements = new ResultingElements();
		binderResultingElements = new ResultingElements();

		normalElements = new HashSet<>();
		boundElements = new HashSet<>();
		notBoundElements = new HashSet<>();
	}

	public void run(RegexJavaAnalyser regexAnalyser) {
		if (!parserRelevantElementsSet.isEmpty()) {
			try {
				regexAnalyser.parseSnippet(input);
				evaluate();
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
	}

	public void evaluate() {
		parserReturnedElementsSet.addAll(normalElements);
		parserReturnedElementsSet.addAll(boundElements);
		parserReturnedElementsSet.addAll(notBoundElements);
		parserResultingElements = TestChecker.check(parserRelevantElementsSet, parserReturnedElementsSet);

		binderSubmittedElementsSet.addAll(boundElements);
		binderSubmittedElementsSet.addAll(notBoundElements);
		parserToBinderResultingElements = TestChecker.check(binderRelevantElementsSet, binderSubmittedElementsSet);

		for (String element : parserToBinderResultingElements.getTruePositives()) {
			if (Pattern.compile("[<]\\w.+[>]").matcher(element).find()) {
				bindableElementsSet.add(element);
			}
		}

		binderReturnedElementsSet.addAll(boundElements);
		binderResultingElements = TestChecker.check(bindableElementsSet, binderReturnedElementsSet);
	}

	public String getInput() {
		return input;
	}

	public Set<String> getParserRelevantElementsSet() {
		return parserRelevantElementsSet;
	}

	public Set<String> getParserReturnedElementsSet() {
		return parserReturnedElementsSet;
	}

	public Set<String> getBinderRelevantElementsSet() {
		return binderRelevantElementsSet;
	}

	public Set<String> getBinderSubmittedElementsSet() {
		return binderSubmittedElementsSet;
	}

	public Set<String> getBindableElementsSet() {
		return bindableElementsSet;
	}

	public Set<String> getBinderReturnedElementsSet() {
		return binderReturnedElementsSet;
	}

	public ResultingElements getParserResultingElements() {
		return parserResultingElements;
	}

	public ResultingElements getParserToBinderResultingElements() {
		return parserToBinderResultingElements;
	}

	public ResultingElements getBinderResultingElements() {
		return binderResultingElements;
	}

	public void addNormalElement(String element) {
		normalElements.add(element);
	}

	public void addBoundElement(String element) {
		boundElements.add(element);
	}

	public void addNotBoundElement(String element) {
		notBoundElements.add(element);
	}

	public List<XWPFParagraph> getCodeParagraphs() {
		return codeParagraphs;
	}

	public void setCodeParagraph(List<XWPFParagraph> codeParagraphs) {
		this.codeParagraphs = codeParagraphs;
	}
}