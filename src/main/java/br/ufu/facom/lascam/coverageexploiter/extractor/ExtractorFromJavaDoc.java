package br.ufu.facom.lascam.coverageexploiter.extractor;

import br.ufu.facom.lascam.coverageexploiter.exception.ExtractorException;
import net.htmlparser.jericho.CharacterReference;
import net.htmlparser.jericho.Element;
import net.htmlparser.jericho.HTMLElementName;
import net.htmlparser.jericho.Source;

import java.io.File;
import java.net.URISyntaxException;
import java.util.*;

/**
 * Created by Klerisson on 15/09/2014.
 */
public class ExtractorFromJavaDoc implements ApiExtractor {

    private List<File> filesInput;
    private final String targetApi;
    private Map<String, Set<String>> classesToMethodsMap;
    private Set<String> packagesSet;

    public ExtractorFromJavaDoc(String folderPath, String targetApi) throws Exception {
        super();
        this.filesInput = new ArrayList<>();
        fillFilesList(new File(this.getClass().getResource("/" + folderPath).toURI()));
        this.classesToMethodsMap = new HashMap<>();
        this.targetApi = targetApi;
    }

    private void fillFilesList(File folderPath) throws URISyntaxException {
        File[] files = folderPath.listFiles();
        for (File file : files) {
            if (file.isFile()) {
                filesInput.add(file);
            } else {
                this.fillFilesList(file);
            }
        }
    }

    public void extract() {

        for (File sourceUrlString : this.filesInput) {

            try {
                Source source = new Source(sourceUrlString);
                source.fullSequentialParse();
                String className = this.getClassName(source);
                if (className.startsWith(this.targetApi)) {
                    Set<String> methods = this.getClassMethods(source);
                    this.classesToMethodsMap.put(className, methods);
                }
            } catch (ExtractorException ee) {
                continue;
            } catch (Exception e) {
                System.err.println("Extraction fail: ");
                e.printStackTrace();
                throw new ExtractorException();
            }
        }
    }

    private Set<String> getClassMethods(Source source) {
        List<Element> lElements = source.getAllElements(HTMLElementName.LI);
        Collections.reverse(lElements);
        Set<String> result = new HashSet<>();

        for (Element e : lElements) { //LI
            //check if the table is about methods
            List<Element> tempElements = e.getParentElement().getParentElement().getAllElements("h3");
            if (tempElements.size() > 0 && tempElements.get(0) != null && tempElements.get(0).getContent().toString().equals("Method Detail")) {
                for (Element temp : tempElements) {

                    List<Element> preList = e.getAllElements("pre");
                    for (Element pre : preList) {
                        String preContent = pre.getTextExtractor().toString();
                        preContent = preContent.substring(0, (preContent.indexOf(")") + 1));
                        result.add(preContent);
                    }
                    break;
                }
            }
        }
        return result;
    }

    private String getClassName(Source source) throws ExtractorException {

        try {

            if (source.getAllElementsByClass("header") != null) {
                List<Element> lElements = source.getAllElementsByClass(HTMLElementName.HEADER).get(0).getAllElements();
                String pkgName = CharacterReference
                        .decodeCollapseWhiteSpace(lElements.get(0).getAllElementsByClass("subTitle").get(0).getContent());
                String className = CharacterReference
                        .decodeCollapseWhiteSpace(lElements.get(0).getAllElementsByClass("title").get(0).getContent());
                //handle white space between "Class" and its name
                int idx = className.indexOf(' ');
                return (pkgName + '.' + className.substring(idx + 1));

            } else {
                throw new ExtractorException();
            }
        } catch (Exception e) {
            throw new ExtractorException(e);
        }
    }

    public Map<String, Set<String>> getClassesToMethodsMap() {
        return classesToMethodsMap;
    }

}
