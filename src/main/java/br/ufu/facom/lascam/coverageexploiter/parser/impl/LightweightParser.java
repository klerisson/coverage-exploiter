package br.ufu.facom.lascam.coverageexploiter.parser.impl;

import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class LightweightParser {

    public static final Pattern PARENTHESES_REGEX = Pattern.compile("(?u)([.\\w]+)\\s*\\((.*)\\)");
    List<String> keyWordsBeforeParens = (List<String>) Arrays.asList("while", "for",
            "if", "try", "catch", "switch");
    Map<String, String> bindingsMap = new HashMap<String, String>();
    String NEW_LINE = "\n";

    String lightWeightFacts = "";
    StringBuilder codeSnippetExample = new StringBuilder("")
            .append("BigDecimal velocity = new BigDecimal(-0.07);")
            .append(NEW_LINE)
            .append("BigDecimal afterMultiplyingBy200 = velocity.multiply( new BigDecimal(200.0) );")
            .append(NEW_LINE)
            .append("BigDecimal floored = afterMultiplyingBy200.setScale(0, RoundingMode.FLOOR);")
            .append(NEW_LINE);

    public static void main(String[] args) {

        LightweightParser lwp = new LightweightParser();

        //This map stores all bindings for a code snippet (i.e., variableName -> variableType)
        //Before call 'extractPP1LightWeightFacts' method for an input snippet,
        //you must have to CLEAR this map
        lwp.bindingsMap.clear();

        String codeSnippetTxt = lwp.codeSnippetExample.toString();
        if (codeSnippetTxt != null && !codeSnippetTxt.equals("")) {
            System.out.println("code snippet: " + codeSnippetTxt);
            lwp.lightWeightFacts = lwp.extractPP1LightWeightFacts(codeSnippetTxt);
        }

        System.out.println("bindingsMap: " + lwp.bindingsMap);

        if (lwp.lightWeightFacts != null && !lwp.lightWeightFacts.equals("")) {
            lwp.lightWeightFacts = lwp.lightWeightFacts.replaceAll("\n", " ");
            System.out.println("");
            System.out.println("Response ==> " + lwp.lightWeightFacts);
        }
    }

    /**
     * This method processes the code snippet and extracts the method calls
     * Features of the Lightweight Parser:
     *
     * - Lightweight Syntactic Analysis
     * - Lightweight Binding
     *
     * @param codeText
     * @return method calls for a snippet
     */
    public String extractPP1LightWeightFacts(String codeText) {
        CodeParser codeParser = new CodeParser();
        String[] codeLines = codeParser.getCodeLinesVet(codeText);
        String respFinal = "";
        String[] vet;
        for (String line : codeLines) {
            line = line.replaceAll("e.printStackTrace", "");
            line = line.replaceAll("System.out.println", "");
            line = line.replaceAll("main", "");
            line = line.replaceAll("return", "");
            line = line.replaceAll("void", "");
            line = line.replaceAll("static", "");
            line = line.replaceAll("public", "");
            line = line.replaceAll("private", "");
            line = line.replaceAll("protected", "");
            line = line.replaceAll("import", "");
            line = line.replaceAll("package", "");

//			System.out.println("linha: " + line);
            if (line.contains(";") && !line.contains("=")) {
//				System.out.println("[-1] declaracao na linha: " + line);
                line = line.trim();
                vet = line.split(";");
                if (vet.length > 0) {
                    line = vet[0];
                    populateBindingMapForDeclaration(line);
                }
            }

            if (line.contains(";") && line.contains("=")) {
                populateBindingMapForAtribution(line);
            }
            respFinal += containsMethodCall(line, "");
        }
        return respFinal;
    }

    private void populateBindingMapForDeclaration(String text) {
        String[] command;
        String[] cmd;
        String variableName;
        String variableType;
        String temp;
        if (!text.contains(",")) {
            cmd = text.split(" ");
            if (cmd.length == 2) {
                variableType = cmd[0];
                variableName = cmd[1];

                bindingsMap.put(variableName, variableType);
            }
        } else {
            command = text.split(",");
            temp = command[0];
            cmd = temp.split(" ");

            if (cmd.length == 2) {
                variableType = cmd[0];
                variableName = cmd[1];

                bindingsMap.put(variableName, variableType);

                for (int i = 1; i < command.length; i++) {
                    temp = command[i].trim();
                    variableName = temp;

                    bindingsMap.put(variableName, variableType);
                }
            }
        }
//		System.out.println("map = " + bindingsMap);
    }

    private void populateBindingMapForAtribution(String text) {
//		System.out.println("atribuicao na linha: " + text);
        text = text.trim();
        text = text.split(";")[0];
        String[] command = text.split("=");
        String temp = command[0];
        String[] vet = temp.split(" ");
        String type = "";
        String variable = "";
        if (vet.length == 2) {
            type = vet[0];
            variable = vet[1];
//			System.out.println("[3] bindingsMap var: " + variable + " type = " + type);
            bindingsMap.put(variable, type);
        }
    }

    public String containsMethodCall(final String s, String resp) {
        final Matcher matcher = PARENTHESES_REGEX.matcher(s);
        String variableName = "";
        String variableType = "";
//		String resp = "";
        String[] temp;
        String[] vet;

        try {
            while (matcher.find()) {
                String beforeParens = matcher.group(1);
                String insideParens = matcher.group(2);
//				System.out.println("beforeParens: " + beforeParens);
//				System.out.println("insideParens: " + insideParens);
                if (keyWordsBeforeParens.contains(beforeParens)) {
//				System.out.println("Keyword: " + beforeParens);
//				System.out.println("insideParens: " + insideParens);
                    return containsMethodCall(insideParens, resp);
                } else {
                    if (beforeParens.contains(".")) {
                        temp = beforeParens.split("\\.");
                        if (temp.length > 0) {
                            variableName = temp[0];
                            if (bindingsMap.containsKey(variableName)) {
                                variableType = bindingsMap.get(variableName);
                                beforeParens = beforeParens.replaceAll(variableName, variableType);
                            }
                        }
                        resp += "MethodCall_" + beforeParens + "\n";
                        vet = beforeParens.split("\\.");
                        if (vet.length > 1) {
                            resp += "MethodCall_" + vet[1] + "\n";
                            if (vet[1].contains("valueOf") || vet[1].contains("subtract")) {
//								System.out.println("-- insideParens: " + insideParens);
                                return containsMethodCall(insideParens, resp);
                            }
                        }
                        System.out.println(resp);
                    } else {
                        //verifica quais os tipos que estao na declaracao do metodo
                        //faz o map dos argumentos do metodo com seus respectivos tipos
                        String[] vetor;
                        String argument;
                        String[] aux;
                        if (insideParens.contains(",")) {
                            //caso em que o metodo possui mais de um argumento
                            vetor = insideParens.split(",");
                            for (int i = 0; i < vetor.length; i++) {
                                argument = vetor[i].trim();
//								System.out.println("argument = " + argument);
                                aux = argument.split(" ");
                                if (aux.length == 2) {
                                    variableType = aux[0];
                                    variableName = aux[1];
                                    bindingsMap.put(variableName, variableType);
//									System.out.println("[4] methodArgument bindingsMap " +
//											"var: " + variableName + " type = " + variableType);
                                }
                            }
                        } else {
                            //caso em que o metodo possui somente um argumento
                            argument = insideParens.trim();
                            aux = argument.split(" ");
                            if (aux.length == 2) {
                                variableType = aux[0];
                                variableName = aux[1];
                                bindingsMap.put(variableName, variableType);
//								System.out.println("[5] methodArgument bindingsMap " +
//										"var: " + variableName + " type = " + variableType);
                            }
                        }
                    }
                    return resp;
                }
            }
        } catch (Exception e) {
            return "";
        }
        return "";
    }
}