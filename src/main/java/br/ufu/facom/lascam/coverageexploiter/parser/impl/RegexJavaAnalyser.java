package br.ufu.facom.lascam.coverageexploiter.parser.impl;

import br.ufu.facom.lascam.coverageexploiter.parser.Parser;
import br.ufu.facom.lascam.coverageexploiter.parser.model.ApiElement;
import br.ufu.facom.lascam.coverageexploiter.parser.model.ApiElements;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Created by Klerisson on 11/11/2014.
 */
public class RegexJavaAnalyser extends Parser {

    /**
     *  Pattern to find constructors, methods declaration and call.
     */
    private static final Pattern PATTERN = Pattern.compile("(?!\\bif\\b|\\bfor\\b|\\bwhile\\b|\\bswitch\\b|\\btry\\b|\\bcatch\\b)(\\b[\\w]+\\b)[\\s\\n\\r]*(?=\\(.*\\))");

    /**
     * Pattern to find methods caller
     */
    private static final Pattern QUALIFIED_PATTERN = Pattern.compile("(\\w+\\.*)(\\w+\\.[\\s\\n\\r]*[\\w]+)[\\s\\n\\r]*(?=\\(.*\\))");

    /**
     * Pattern to find class declaration
     */
    private static final Pattern CLASS_DECLARATION_PATTERN = Pattern.compile("(\\s+implements\\s+([\\w,\\s]+))?\\s*\\{.*$");

    @Override
    public ApiElements parseSnippet(String statement) throws Exception {
        ApiElement apiElement = new ApiElement();
        Set<String> elementsSet = new HashSet<>();

        //For qualified methods calls
        Matcher m = QUALIFIED_PATTERN.matcher(statement);
        while(m.find()) {
            //System.out.println(m.group());
            if(isVariableCaller(m.group())){
                elementsSet.add(bind(m.group(), statement));
            } else {
                elementsSet.add(m.group());
            }
        }
        //For unqualified methods calls and constructors
        m = PATTERN.matcher(statement);
        while (m.find()) {
            elementsSet.add(m.group());
        }

        apiElement.setElements(new ArrayList<>(elementsSet));
        super.apiElements.getApiElements().add(apiElement);
        return super.apiElements;
    }

    private String bind(String expression, String snippet) {
        String variable = expression.substring(0,expression.indexOf(".")).trim();
        Matcher m = Pattern.compile("(\\s?\\w+\\s(" + variable + ")+\\s?(;|=|\\)))").matcher(snippet);
        if(m.find()){
            String type = m.group().trim();
            type = type.substring(0,type.indexOf(" "));
            return type + expression.substring(expression.lastIndexOf("."));
        } else {
            return expression.substring(expression.lastIndexOf(".") + 1);
        }
    }

    private boolean isVariableCaller(String expression) {
        return !Character.isUpperCase(expression.charAt(0)) && !expression.startsWith("this.") && !expression.startsWith("super.");
    }
}
