package br.ufu.facom.lascam.coverageexploiter.parser.impl;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

import br.ufu.facom.lascam.coverageexploiter.parser.Parser;
import br.ufu.facom.lascam.coverageexploiter.parser.model.CitedElements;

/**
 * Created by Klerisson on 11/11/2014.
 */
public class RegexJavaAnalyser extends Parser {
	
	/**
     * Pattern to find class fully qualified name
     */
    private static final Pattern CLASS_FULLY_QUALIFIED_NAME_PATTERN = Pattern.compile("\\b([a-z][a-z_0-9]*\\.)+([A-Z_]($[A-Z_]|[\\w_])*\\.)*([A-Z_]($[A-Z_]|[\\w_])*)\\b");
    
    /**
     * Pattern to find package import without specific type (e.g., import <>.<>.<>.*;), because CLASS_FULLY_QUALIFIED_NAME_PATTERN finds the others
     */
    private static final Pattern PACKAGE_IMPORT_PATTERN = Pattern.compile("\\b([a-z][a-z_0-9]*\\.)+[*]\\B");
    
    /**
     * Pattern to find class and interface declaration
     */
    private static final Pattern CLASS_INTERFACE_DECLARATION_PATTERN = Pattern.compile("([^\\.]\\bclass\\b\\s+\\w+)|(\\binterface\\b\\s+\\w+)");
	
    /**
     * Pattern to find extends and implements declaration
     */
    private static final Pattern EXTENDS_IMPLEMENTS_DECLARATION_PATTERN = Pattern.compile("(\\bextends\\b\\s+\\w+)|(\\bimplements\\b\\s+[\\w,\\s]+)");
    
    /**
     * Pattern to find variable declaration (including in method arguments)
     */
    private static final Pattern VARIABLE_DECLARATION_PATTERN = Pattern.compile("((?!\\bbyte\\b|\\bshort\\b|\\bint\\b|\\blong\\b|\\bfloat\\b|\\bdouble\\b|\\bchar\\b|\\bString\\b|\\bboolean\\b|\\bpackage\\b|\\breturn\\b)\\b[\\w]+\\b\\s\\b[\\w]+\\b\\s?(;|=|\\)|,|:))");
    
    /**
     * Pattern to find qualified calls (including constructors calls), i.e., calls using an object or a class
     */
    private static final Pattern QUALIFIED_METHOD_CALL_PATTERN = Pattern.compile("((\\w+\\.)+[\\s\\n\\r]*[\\w]+)[\\s\\n\\r]*(?=\\(.*\\))");
    
    /**
     *  Pattern to find unqualified calls (including constructors calls) and methods declaration.
     */
    private static final Pattern UNQUALIFIED_METHOD_CALL_AND_DECLARATION_PATTERN = Pattern.compile("([^\\.](?!\\bif\\b|\\bfor\\b|\\bwhile\\b|\\bswitch\\b|\\btry\\b|\\bcatch\\b)\\b[\\w]+\\b)[\\s\\n\\r]*(?=\\(.*\\))");

    @Override
    public CitedElements parseSnippet(String snippet) throws Exception {
        CitedElements citedElements = new CitedElements();

        // Removes comments
        String cleanSnippet = snippet.replaceAll("((?s)(/\\*.*?\\*/))|(?://.*)", "");
        
        String packName, className, methodName;
        String[] aux;
        
        Matcher m = CLASS_FULLY_QUALIFIED_NAME_PATTERN.matcher(cleanSnippet);
        while (m.find()) {
        	className = m.group();
        	packName = separatePackageName(className);
        	citedElements.addClass(className); // class
            citedElements.addPackage(packName); // package
        }
        
        m = PACKAGE_IMPORT_PATTERN.matcher(cleanSnippet);
        while (m.find()) {
        	citedElements.addPackage(m.group().replace(".*", ""));
        }
        
        m = CLASS_INTERFACE_DECLARATION_PATTERN.matcher(cleanSnippet);
        while (m.find()) {
        	className = m.group().replaceAll("class|interface|\\s", "");
        	citedElements.addClass(className); // class
        }
        
        m = EXTENDS_IMPLEMENTS_DECLARATION_PATTERN.matcher(cleanSnippet);
        while (m.find()) {
        	aux = m.group().replaceAll("extends|implements|\\s", "").split(",");
        	int i = 0;
        	while (i < aux.length) {
        		className = bindClass(aux[i], cleanSnippet);
        		citedElements.addClass(className); // class
        		if (Character.isLowerCase(className.charAt(0))) {
        			packName = separatePackageName(className);
        			citedElements.addPackage(packName); // package
        		}
        		i++;
        	}
        }
        
        m = VARIABLE_DECLARATION_PATTERN.matcher(cleanSnippet);
        while (m.find()) {
        	className = m.group().trim();
        	className = className.substring(0, className.indexOf(" "));
        	className = bindClass(className, cleanSnippet);
    		citedElements.addClass(className); // class
    		if (Character.isLowerCase(className.charAt(0))) {
    			packName = separatePackageName(className);
    			citedElements.addPackage(packName); // package
    		}
        }
        
        m = QUALIFIED_METHOD_CALL_PATTERN.matcher(cleanSnippet);
        while (m.find()) {
            if(isVariableCaller(m.group())){
            	methodName = bindMethod(m.group(), cleanSnippet);
            	if (methodName.contains(".")) {
            		packName = separatePackageName(methodName);
            		if (!packName.isEmpty()) {
            			citedElements.addPackage(packName); // package
            			className = methodName.substring(0, methodName.lastIndexOf("."));
            			citedElements.addPackage(className); // class
            		} else {
            			className = bindClass(methodName.substring(0, methodName.lastIndexOf(".")), cleanSnippet);
                		citedElements.addClass(className); // class
                		if (Character.isLowerCase(className.charAt(0))) {
                			packName = separatePackageName(className);
                			citedElements.addPackage(packName); // package
                			methodName = packName + "." + methodName;
                		}
            		}
            	}
            	citedElements.addMethod(methodName); // method
            } else {
            	methodName = m.group();
            	packName = separatePackageName(methodName);
        		if (!packName.isEmpty()) {
        			citedElements.addPackage(packName); // package
        			className = methodName.substring(0, methodName.lastIndexOf("."));
        			citedElements.addPackage(className); // class
        		} else {
        			className = bindClass(methodName.substring(0, methodName.lastIndexOf(".")), cleanSnippet);
            		citedElements.addClass(className); // class
            		if (Character.isLowerCase(className.charAt(0))) {
            			packName = separatePackageName(className);
            			citedElements.addPackage(packName); // package
            			methodName = packName + "." + methodName;
            		}
        		}
        		citedElements.addMethod(methodName); // method
            }
        }
        
        m = UNQUALIFIED_METHOD_CALL_AND_DECLARATION_PATTERN.matcher(cleanSnippet);
        while (m.find()) {
        	methodName = m.group().replaceAll("[^\\w]", "");
        	if (isConstructor(methodName)) {
        		className = bindClass(methodName, cleanSnippet);
        		citedElements.addClass(className); // class
        		if (Character.isLowerCase(className.charAt(0))) {
        			packName = separatePackageName(className);
        			citedElements.addPackage(packName); // package
        			methodName = packName + "." + methodName;
        		}
    		}
    		citedElements.addMethod(methodName); // method
        }
        
        super.citedElements = citedElements;
        return super.citedElements;
    }

    private String bindMethod(String expression, String snippet) {
        String variable = expression.substring(0,expression.indexOf(".")).trim();
        Matcher m = Pattern.compile("(\\s?\\w+\\s(" + variable + ")+\\s?(;|=|\\)|,|:))").matcher(snippet);
        if(m.find()){
            String type = m.group().trim();
            type = type.substring(0,type.indexOf(" "));
            return type + expression.substring(expression.lastIndexOf("."));
        } else {
            return expression.substring(expression.lastIndexOf(".") + 1);
        }
    }
    
    private String bindClass(String expression, String snippet) {
    	Matcher m = Pattern.compile("\\b([a-z][a-z_0-9]*\\.)+(" + expression + ")\\b").matcher(snippet);
    	if (m.find()) {
    		return m.group();
    	} else {
    		return expression;
    	}
    }

    private boolean isVariableCaller(String expression) {
    	if (CLASS_FULLY_QUALIFIED_NAME_PATTERN.matcher(expression).find()) {
    		return false;
    	}
        return !Character.isUpperCase(expression.charAt(0)) && !expression.startsWith("this.") && !expression.startsWith("super.");
    }
    
    public static boolean isConstructor(String expression) {
        return Character.isUpperCase(expression.charAt(0));
    }
    
    public static String separatePackageName(String name) {
    	String packName = "";
    	
    	String[] aux = name.split("\\.");
    	int i = 0;
    	while (i < aux.length && !Character.isUpperCase(aux[i].charAt(0))) {
    		packName += aux[i++] + ".";
    	}
    	
    	if (!packName.isEmpty()) {
    		packName = packName.substring(0, packName.length() - 1);
    	}
    	
    	return packName;
    }
}
